.section .data
    topoInicialHeap: .quad 0            # valor origial de brk (antes das alocações)
    topoHeap: .quad 0                   # ponteiro para o fim da heap (atual brk)
    listaLivres: .quad 0
    listaOcupados: .quad 0
    format_str:     .string "%c"
    newline_str:    .string "\n"
    vazio_str:      .string "<vazio>\n"
    char_hash:      .byte '#'
    char_plus:      .byte '+'
    char_minus:     .byte '-'

.section .text
.globl iniciaAlocador
.globl finalizaAlocador
.globl removeDaLista
.globl adicionaNaLista
.globl alocaMem
.globl liberaMem
.globl imprimeMapa
.extern printf

# --------------------------------- iniciaAlocador -----------------------------------
iniciaAlocador:
    pushq %rbp                          # empilha (salva) %rbp
    movq %rsp, %rbp                     # faz %rbp apontar para novo R.A 

    movq $0, %rdi                       # argumento 0 para buscar o topo atual da heap
    movq $12, %rax                      # syscall numero 12 = brk
    syscall                             # executa a syscall

    movq %rax, topoInicialHeap(%rip)
    movq %rax, topoHeap(%rip)
    movq $0, listaLivres(%rip)
    movq $0, listaOcupados(%rip)

    popq %rbp                           # restaura %rbp
    ret                                 # retorna ao chamador


# --------------------------------- finalizaAlocador ----------------------------------
finalizaAlocador:
    pushq %rbp
    movq %rsp, %rbp
    movq $0, %rdi                       # argumento 0 para buscar o topo atual da heap
    movq $12, %rax                      # syscall numero 12 = brk
    syscall                             # executa a syscall

    movq topoInicialHeap(%rip), %rdi    # Redefine brk para o topo inicial
    movq $12, %rax
    syscall

    movq topoInicialHeap(%rip), %rsi
    movq %rsi, topoHeap(%rip)
    movq $0, listaLivres(%rip)
    movq $0, listaOcupados(%rip)

    popq %rbp
    ret

# --------------------------------- removeDaLista ----------------------------------
removeDaLista:
    pushq %rbp
    movq %rsp, %rbp
    
    # rdi = Bloco** lista
    # rsi = Bloco* alvo
    movq (%rdi), %rax          # rax = *lista
    
    cmpq $0, %rax              # if (*lista == NULL) return
    je fim_remove
    cmpq $0, %rsi              # if (alvo == NULL) return
    je fim_remove
    
    cmpq %rax, %rsi            # if (*lista == alvo)
    jne procura_remove
    
    # *lista = alvo->prox
    movq 16(%rsi), %rdx        # rdx = alvo->prox
    movq %rdx, (%rdi)
    jmp fim_remove

procura_remove:
    movq %rax, %rcx            # rcx = atual
    
loop_remove:
    movq 16(%rcx), %rdx        # rdx = atual->prox
    cmpq $0, %rdx              # if (atual->prox == NULL) break
    je fim_remove
    
    cmpq %rdx, %rsi            # if (atual->prox == alvo)
    jne continua_remove
    
    # atual->prox = alvo->prox
    movq 16(%rsi), %r8
    movq %r8, 16(%rcx)
    jmp fim_remove

continua_remove:
    movq %rdx, %rcx
    jmp loop_remove

fim_remove:
    popq %rbp
    ret


# --------------------------------- adiocionaNaLista ----------------------------------
adicionaNaLista:
    pushq %rbp
    movq %rsp, %rbp
    
    # rdi = Bloco** lista
    # rsi = Bloco* bloco
    
    movq (%rdi), %rax          # rax = *lista
    movq %rax, 16(%rsi)        # bloco->prox = *lista
    movq %rsi, (%rdi)          # *lista = bloco
    
    popq %rbp
    ret

# --------------------------------- alocaMem -----------------------------------
alocaMem:
    pushq %rbp
    movq %rsp, %rbp
    pushq %rbx
    pushq %r12
    pushq %r13

    movq %rdi, %rbx             # %rbx = num_bytes
    movq listaLivres(%rip), %r12 # %r12 = atual (iterador)

procura_bloco_livre:
    cmpq $0, %r12               # if (atual == NULL)
    je aloca_novo_bloco

    # Verifica se o bloco livre tem tamanho suficiente
    movq 8(%r12), %r13         # %r13 = atual->tamanho
    cmpq %rbx, %r13
    jl proximo_bloco

    # Bloco adequado encontrado
    movl $1, (%r12)            # marca como ocupado
    movq %r12, %rdi            # arg1 = bloco
    leaq listaLivres(%rip), %rsi # arg2 = &listaLivres
    call removeDaLista

    movq %r12, %rdi            # arg1 = bloco
    leaq listaOcupados(%rip), %rsi # arg2 = &listaOcupados
    call adicionaNaLista

    leaq 24(%r12), %rax        # retorna ponteiro para área de dados (bloco + 24)
    jmp fim_aloca

proximo_bloco:
    movq 16(%r12), %r12        # atual = atual->prox
    jmp procura_bloco_livre

aloca_novo_bloco:
    # Calcula tamanho total necessário
    movq %rbx, %rdi
    addq $24, %rdi             # sizeof(Bloco) = 24

    # Chamada sbrk
    movq $12, %rax             # syscall brk
    movq topoHeap(%rip), %rsi
    addq %rdi, %rsi            # novo topo
    syscall

    cmpq $-1, %rax
    je erro_alocacao

    # Configura novo bloco
    movq topoHeap(%rip), %r12
    movl $1, (%r12)            # ocupado = 1
    movq %rbx, 8(%r12)         # tamanho = num_bytes
    movq $0, 16(%r12)          # prox = NULL

    # Atualiza topoHeap
    movq %rax, topoHeap(%rip)

    # Adiciona na lista de ocupados
    movq %r12, %rdi
    leaq listaOcupados(%rip), %rsi
    call adicionaNaLista

    leaq 24(%r12), %rax        # retorna ponteiro para dados
    jmp fim_aloca

erro_alocacao:
    movq $0, %rax              # retorna NULL

fim_aloca:
    popq %r13
    popq %r12
    popq %rbx
    popq %rbp
    ret


# --------------------------------- liberaMem -----------------------------------
liberaMem:
    pushq %rbp
    movq %rsp, %rbp
    pushq %rbx
    pushq %r12
    pushq %r13

    cmpq $0, %rdi              # if (ptr == NULL)
    je erro_liberacao

    movq %rdi, %rbx
    subq $24, %rbx             # bloco = ptr - sizeof(Bloco)

    # Marca como livre
    movl $0, (%rbx)

    # Remove da lista de ocupados
    movq %rbx, %rdi
    leaq listaOcupados(%rip), %rsi
    call removeDaLista

    # Coalesce com próximo bloco (se livre)
    movq 8(%rbx), %rax         # tamanho do bloco atual
    leaq 24(%rbx, %rax), %r12  # próximo bloco = atual + 24 + tamanho

    cmpq topoHeap(%rip), %r12  # verifica se está dentro da heap
    jge coalesce_anterior

    cmpl $0, (%r12)            # verifica se próximo está livre
    jne coalesce_anterior

    # Remove próximo da lista de livres
    movq %r12, %rdi
    leaq listaLivres(%rip), %rsi
    call removeDaLista

    # Aumenta tamanho do bloco atual
    movq 8(%r12), %rax         # tamanho do próximo
    addq $24, %rax             # adiciona sizeof(Bloco)
    addq %rax, 8(%rbx)

coalesce_anterior:
    # Tenta coalescer com anterior
    movq listaLivres(%rip), %r12
    movq $0, %r13              # anterior = NULL

loop_anterior:
    cmpq $0, %r12
    je fim_coalesce

    movq 8(%r12), %rax         # tamanho do possível anterior
    leaq 24(%r12, %rax), %rdi  # fim do possível anterior
    cmpq %rdi, %rbx            # fim(anterior) == início(atual)?
    jne proximo_anterior

    # Encontrou bloco anterior adjacente
    movq %r12, %r13            # guarda anterior
    jmp coalesce

proximo_anterior:
    movq 16(%r12), %r12        # avança para próximo
    jmp loop_anterior

coalesce:
    # Remove atual da lista de livres (se estiver)
    movq %rbx, %rdi
    leaq listaLivres(%rip), %rsi
    call removeDaLista

    # Aumenta tamanho do anterior
    movq 8(%rbx), %rax         # tamanho do atual
    addq $24, %rax             # adiciona sizeof(Bloco)
    addq %rax, 8(%r13)

    # O bloco coalescido é o anterior
    movq %r13, %rbx

fim_coalesce:
    # Adiciona bloco (coalescido ou não) na lista de livres
    movq %rbx, %rdi
    leaq listaLivres(%rip), %rsi
    call adicionaNaLista

    movq $0, %rax              # retorno de sucesso
    jmp fim_libera

erro_liberacao:
    movq $1, %rax              # retorno de erro

fim_libera:
    popq %r13
    popq %r12
    popq %rbx
    popq %rbp
    ret


# --------------------------------- imprimeMapa -----------------------------------
imprimeMapa:
    pushq %rbp
    movq %rsp, %rbp
    pushq %rbx                          # Salva %rbx (usaremos para bloco atual)
    pushq %r12                          # Salva %r12 (contador)
    pushq %r13                          # Salva %r13 (tamanho do bloco)
    pushq %r14                          # Salva %r14 (símbolo)

    # Verifica se a heap está vazia
    cmpq $0, topoInicialHeap(%rip)
    jne mapa_nao_vazio
    
    # Heap vazia - imprime "<vazio>\n"
    movq $vazio_str, %rdi
    call printf
    jmp fim_imprime_mapa

mapa_nao_vazio:
    movq topoInicialHeap(%rip), %rbx         # %rbx = bloco atual

loop_blocos:
    # Verifica se chegou ao topo da heap
    cmpq topoHeap(%rip), %rbx
    jge fim_loop_blocos

    # Imprime a parte gerencial do bloco (16 bytes de '#')
    movq $16, %r12                      # %r12 = contador (16 bytes)
loop_gerencial:
    cmpq $0, %r12
    jle fim_loop_gerencial
    
    movq $format_str, %rdi              # Formato para printf
    movzbl char_hash(%rip), %esi        # Caractere '#'
    call printf
    
    decq %r12
    jmp loop_gerencial

fim_loop_gerencial:
    # Determina o símbolo a ser impresso (+ ou -)
    cmpl $0, (%rbx)                    # Verifica se bloco está ocupado
    je bloco_livre
    
    movzbl char_plus(%rip), %r14d       # Símbolo '+'
    jmp imprime_dados
    
bloco_livre:
    movzbl char_minus(%rip), %r14d      # Símbolo '-'

imprime_dados:
    # Imprime os dados do bloco (tamanho bytes do símbolo)
    movq 8(%rbx), %r13                  # %r13 = tamanho do bloco
    movq %r13, %r12                     # %r12 = contador

loop_dados:
    cmpq $0, %r12
    jle fim_loop_dados
    
    movq $format_str, %rdi              # Formato para printf
    movl %r14d, %esi                    # Caractere '+' ou '-'
    call printf
    
    decq %r12
    jmp loop_dados

fim_loop_dados:
    # Avança para o próximo bloco
    movq 8(%rbx), %rax                  # %rax = tamanho do bloco atual
    leaq 16(%rbx, %rax), %rbx           # %rbx = próximo bloco (atual + 16 + tamanho)
    jmp loop_blocos

fim_loop_blocos:
    # Imprime nova linha no final
    movq $newline_str, %rdi
    call printf

fim_imprime_mapa:
    popq %r14                           # Restaura registradores
    popq %r13
    popq %r12
    popq %rbx
    popq %rbp
    ret
